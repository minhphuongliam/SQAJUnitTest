//

package com.thanhtam.backend.repository;

import com.sun.org.apache.xpath.internal.objects.XBoolean;
import com.thanhtam.backend.dto.UserExport;
import com.thanhtam.backend.entity.Intake;
import com.thanhtam.backend.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User> findByUsername(String username);

    Boolean existsByUsername(String username);

    Optional<User> findByEmail(String email);
    Boolean existsByEmail(String email);

    Boolean existsByEmailOrUsername(String email, String username);

    public Page<User> findAll(Pageable pageable);

    public Page<User> findAllByDeleted(boolean deleted, Pageable pageable);

    public Page<User> findAllByDeletedAndUsernameContains(boolean deleted, String username, Pageable pageable);
    public Page<User> findAllByUsernameContainsOrEmailContains(String username, String email, Pageable pageable);

    //    public Page<User> findUsersByDeletedAndUsernameIsContainingOrEmailIsContaining(boolean deleted, String username, String email, Pageable pageable);
    List<User> findAllByDeleted(boolean statusDeleted);

    List<User> findAllByIntakeId(Long id);
    List<User> findByDeletedIsFalseOrderByCreatedDateDesc();


}


//

package com.thanhtam.backend.service;

import com.thanhtam.backend.entity.Intake;

import java.util.List;
import java.util.Optional;

public interface IntakeService {
    public Intake findByCode(String code);
    public Optional<Intake> findById(Long id);
    public List<Intake> findAll();

}


//

package com.thanhtam.backend.service;

import com.thanhtam.backend.entity.Role;
import com.thanhtam.backend.ultilities.ERole;

import java.util.Optional;

public interface RoleService {
    Optional<Role> findByName(ERole name);
}


//

package com.thanhtam.backend.service;

import org.springframework.core.io.Resource;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Path;
import java.util.stream.Stream;

public interface FilesStorageService {
    public void initRootFolder();

    public void initExcelFolder();

    public boolean existRootFolder();

    public boolean existExcelFolder();

    public void save(MultipartFile file, String filePath);

    public Resource load(String filename);

    public void deleteAllUserExcel(String fileName) throws IOException;


    public Stream<Path> loadAll();
}


//

package com.thanhtam.backend.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.io.Serializable;
import java.util.List;
import java.util.Set;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "intake")
public class Intake implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "name")
    private String name;

    @Column(name = "intake_code")
    private String intakeCode;
}


//

package com.thanhtam.backend.dto;

import com.opencsv.bean.CsvBindByPosition;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class UserExport {
    @CsvBindByPosition(position = 0)
    private String username;
    @CsvBindByPosition(position = 3)
    private String email;
    @CsvBindByPosition(position = 1)
    private String firstName;
    @CsvBindByPosition(position = 2)
    private String lastName;

}


//

package com.thanhtam.backend.entity;


import com.thanhtam.backend.ultilities.ERole;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.io.Serializable;

@Entity
@Table(name = "role")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Role implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "name")
    private ERole name;
}


//

package com.thanhtam.backend.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;

@Entity
@Table(name = "profile")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Profile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    @Column(name = "image")
    private String image;

}


//

package com.thanhtam.backend.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import javax.persistence.*;
import javax.validation.constraints.Email;
import java.io.Serializable;
import java.util.*;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "users")
public class User implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "username", nullable = false, unique = true)
    private String username;
    @JsonIgnore
    @Column(name = "password")
    private String password;

    @Email
    @Column(name = "email", unique = true, nullable = false)
    private String email;

    @ManyToOne(fetch = FetchType.EAGER )
    @JoinColumn(name = "intake_id")
    private Intake intake;
//
//    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
//    private Set<ExamUser> examUsers = new HashSet<>();

//    @Column(name = "enabled")
//    private boolean enabled = true;
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;

    @CreationTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "created_date", updatable = false, nullable = false)
    private Date createdDate;

    @UpdateTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "lastest_login_date", updatable = true, nullable = true)
    private Date lastLoginDate;


    @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.MERGE)
    @JoinTable(name = "role_user", joinColumns = {@JoinColumn(name = "user_id", referencedColumnName = "id")},
            inverseJoinColumns = {
                    @JoinColumn(name = "role_id", referencedColumnName = "id")})
    private Set<Role> roles;

    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JoinColumn(name = "profile_id", referencedColumnName = "id")
    private Profile profile;

    public User(String username, String email, Profile profile) {
        this.username = username;
        this.email = email;
        this.profile = profile;
    }

    public User(boolean deleted) {
        this.deleted = deleted;
    }

    public User(String username, String password, String email, Profile profile) {
        this.username = username;
        this.password = password;
        this.email = email;
        this.profile = profile;
    }

    public User(String email, Profile profile) {
        this.email = email;
        this.profile = profile;
    }
}


//

package com.thanhtam.backend.service;

import com.thanhtam.backend.dto.UserExport;
import com.thanhtam.backend.entity.Intake;
import com.thanhtam.backend.entity.Profile;
import com.thanhtam.backend.entity.Role;
import com.thanhtam.backend.entity.User;
import com.thanhtam.backend.repository.UserRepository;
import com.thanhtam.backend.ultilities.ERole;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

@Service
public class ExcelServiceImpl implements ExcelService {
    private static final Logger LOGGER = LoggerFactory.getLogger(ExcelServiceImpl.class);
    private final Path root = Paths.get("uploads");
    private FilesStorageService filesStorageService;
    private PasswordEncoder passwordEncoder;
    private UserRepository userRepository;
    private RoleService roleService;
    private IntakeService intakeService;

    @Autowired
    public ExcelServiceImpl(FilesStorageService filesStorageService, PasswordEncoder passwordEncoder, UserRepository userRepository, RoleService roleService, IntakeService intakeService) {
        this.filesStorageService = filesStorageService;
        this.passwordEncoder = passwordEncoder;
        this.userRepository = userRepository;
        this.roleService = roleService;
        this.intakeService = intakeService;
    }

    @Override
    public List<User> readUserFromExcelFile(String excelFilePath) throws IOException {
        List<User> userList = new ArrayList<>();
        FileInputStream inputStream = new FileInputStream(new File(excelFilePath));

        Workbook workBook = getWorkbook(inputStream, excelFilePath);
        Sheet firstSheet = workBook.getSheetAt(0);
        LOGGER.info(firstSheet.getSheetName());
        Iterator<Row> rows = firstSheet.iterator();

        while (rows.hasNext()) {
            Row row = rows.next();
            Iterator<Cell> cells = row.cellIterator();
            User user = new User();
            Profile profile = new Profile();

            while (cells.hasNext()) {
                Cell cell = cells.next();
                int columnIndex = cell.getColumnIndex();

                switch (columnIndex) {
                    case 0: {
                        user.setUsername((String) getCellValue(cell));
                        user.setPassword(passwordEncoder.encode((String) getCellValue(cell)));

                    }
                    break;

                    case 1: {
                        user.setEmail((String) getCellValue(cell));
                    }

                    break;
                    case 2: {
                        profile.setFirstName((String) getCellValue(cell));
                        user.setProfile(profile);

                    }

                    break;
                    case 3: {
                        profile.setLastName((String) getCellValue(cell));
                        user.setProfile(profile);

                    }

                    break;

                    case 4: {
                        Intake intake = intakeService.findByCode((String) getCellValue(cell));
                        user.setIntake(intake);
                    }
                    case 5: {
                        switch ((String) getCellValue(cell)) {
                            case "ADMIN": {
                                Role userRole = roleService.findByName(ERole.ROLE_ADMIN).orElseThrow(() -> new RuntimeException("Error: Role is not found"));
                                Set<Role> roles = new HashSet<>();
                                roles.add(userRole);
                                user.setRoles(roles);
                                break;
                            }

                            case "LECTURER": {
                                Role userRole = roleService.findByName(ERole.ROLE_LECTURER).orElseThrow(() -> new RuntimeException("Error: Role is not found"));
                                Set<Role> roles = new HashSet<>();
                                roles.add(userRole);
                                user.setRoles(roles);
                                break;
                            }

                            default: {
                                Role userRole = roleService.findByName(ERole.ROLE_STUDENT).orElseThrow(() -> new RuntimeException("Error: Role is not found"));
                                Set<Role> roles = new HashSet<>();
                                roles.add(userRole);
                                user.setRoles(roles);
                                break;
                            }
                        }
                    }
                    break;
                }

            }

            userList.add(user);
        }

        workBook.close();
        inputStream.close();
        LOGGER.error("List user: " + userList.toString());
        return userList;
    }

    @Override
    public void writeUserToExcelFile(ArrayList<UserExport> userExports) throws IOException {
        try (Workbook workbook = new XSSFWorkbook()) {
            String[] columns = {"Username", "Họ và tên", "Email"};
            Sheet sheet = workbook.createSheet("List of users");
            //Custom style
            Font headerFont = workbook.createFont();
            headerFont.setBold(true);
            headerFont.setFontHeightInPoints((short) 14);
            headerFont.setColor(IndexedColors.RED.getIndex());

            // Create a CellStyle with the font
            CellStyle headerCellStyle = workbook.createCellStyle();
            headerCellStyle.setFont(headerFont);

            // Create a Row
            Row headerRow = sheet.createRow(0);

            // Create cells
            for (int i = 0; i < columns.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(columns[i]);
                cell.setCellStyle(headerCellStyle);
            }

            // Create Other rows and cells with employees data
            int rowNum = 1;
            for (UserExport user : userExports) {
                Row row = sheet.createRow(rowNum++);

                // Employee's name (Column A)
                row.createCell(0)
                        .setCellValue(user.getUsername());

                // Employee's email (Column B)
                row.createCell(1)
                        .setCellValue(user.getFirstName());

                row.createCell(2)
                        .setCellValue(user.getLastName());

                row.createCell(3)
                        .setCellValue(user.getEmail());
            }
            // Making size of column auto resize to fit with data
            sheet.autoSizeColumn(0);
            sheet.autoSizeColumn(1);
            sheet.autoSizeColumn(2);
            sheet.autoSizeColumn(3);
            FileOutputStream fileOut = new FileOutputStream("users.xlsx");

            workbook.write(fileOut);
            fileOut.close();

        } catch (IOException e) {
            e.printStackTrace();

        }

    }

    @Override
    public void InsertUserToDB(List<User> userList) {
        userList.forEach(user -> {
            if (userRepository.existsByEmailOrUsername(user.getEmail(), user.getUsername())) {
                try {
                    throw new Exception("Username or email has already existed");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else {
                userRepository.save(user);
            }
        });

    }

    private Object getCellValue(Cell cell) {
        switch (cell.getCellType()) {
            case Cell.CELL_TYPE_STRING:
                return cell.getStringCellValue();

            case Cell.CELL_TYPE_BOOLEAN:
                return cell.getBooleanCellValue();

            case Cell.CELL_TYPE_NUMERIC:
                return cell.getNumericCellValue();
        }

        return null;
    }

    private Workbook getWorkbook(FileInputStream inputStream, String excelFilePath) throws IOException {
        Workbook workbook = null;

        if (excelFilePath.endsWith("xlsx")) {
            workbook = new XSSFWorkbook(inputStream);
        } else if (excelFilePath.endsWith("xls")) {
            workbook = new HSSFWorkbook(inputStream);
        } else {
            throw new IllegalArgumentException("The specified file is not Excel file");
        }

        return workbook;
    }
}
